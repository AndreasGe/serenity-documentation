Sometimes projects have a lot of tests, and executing of them takes a lot of time. Testing can be sped up significantly by running different tests in parallel. However, this is often harder to implement than it sounds.

Some build automation tools have builtin parallel test execution, but this not so good for huge amount of tests and heavy tests. For example web tests are as a rule much slower than other types of tests, it make them good candidates for concurrent testing, in theory at least, but the implementation can be tricky. For example, although it is easy enough to configure running tests in parallel, on the other hand running several webdriver instances of Firefox/Chrome in parallel on the same display, tends to become unreliable.

The natural solution in this case is to split the web tests into smaller batches, and to run each batch on a different machine and/or on a different virtual display. When each batch has finished, the results can be retrieved and aggregated into the final test reports.

However splitting tests into batches by hand tends to be tedious and unreliable – it is easy to forget to add a new test to a batch, for example, or have unevenly-distributed batches.

Serenity lets you do this automatically, by splitting your test cases evenly into batches of a given size. In practice, you run a build job for each batch - you take same sources with all tests and configure serenity to run from current copy some amount of test by providing several parameters. After that you retrieve all tests results generated by each batch to aggregate into the final serenity test report.

=== Splitting serenity tests to batches
To split tests to batches you need configure serenity run some tests and skip others. For different batches it will be different tests, below you can find short example of such configuration.

For configuration batches three parameters are used:

*serenity.batch.strategy*:: Optional parameter for choosing batch creating strategy. Possible values are `DIVIDE_EQUALLY` and `DIVIDE_BY_TEST_COUNT`. Default value is `DIVIDE_EQUALLY`. Instead of it can be used redundant `thucydides.batch.strategy`, but it strongly not recommended

*serenity.batch.size*:: This parameter should be the same for each batch, and should more than 0. This is amount of all bathes for current sources, and synonym of 'serenity.batch.count'. Instead of it can be used redundant `thucydides.batch.size`, but it strongly not recommended

*serenity.batch.count*:: This parameter should be the same for each batch, and should more than 0. This is amount of all bathes for current sources, and synonym of 'serenity.batch.size'. Instead of it can be used redundant `thucydides.batch.count`, but it strongly not recommended

*serenity.batch.number*:: This parameter should be different for each batch, and should be less or equal `serenity.batch.size` and more than 0. This is number of bath for execution in current build. Instead of it can be used redundant `thucydides.batch.number`, but it strongly not recommended

Those parameters can be populated as system parameters of in serenity.properties file. Meaning of parameters size/number depends on `serenity.batch.strategy` value. For explanation strategies will be used tests with next structure (full sources available under https://github.com/serenity-bdd/serenity-demos[serenity-demos] repository):

[source,java]
----
...
include::{srcdir}/junit-batch-configuration-example/src/test/java/net/serenity/samples/batch/junit/features/registration/LoginUserTest.java[]
----

[source,java]
----
...
include::{srcdir}/junit-batch-configuration-example/src/test/java/net/serenity/samples/batch/junit/features/registration/RegisterUserTest.java[]
----

[source,java]
----
...
include::{srcdir}/junit-batch-configuration-example/src/test/java/net/serenity/samples/batch/junit/features/registration/UserActivationProcessTest.java[]
----

Screenshot for aggregation report created after executing all tests without enabling batches (`serenity.batch.count` and `serenity.batch.number` and `serenity.batch.size` aren't provided or equal to 0). It contains all Tests from above classes:

[[fig-serenity-report-for-bathes-example-project]]
.Serenity report for bathes example project with turned off batching
image::junit-batches-all-test-cases.png[]


==== Divide tests to batches using DIVIDE_EQUALLY batch strategy

This strategy enabled by default. It allows split all test classes among `serenity.batch.size` batches. Value `serenity.batch.number` will refer to some batch and only tests from Test classes from this batch will be executed.When test phase will be started Serenity will check if `serenity.batch.size > 0` and `serenity.batch.number > 0`, and if so it will split tests classes to `serenity.batch.size` batches and run batch with number equal to `serenity.batch.number`.
All classes will be included to bathes one by one. So if size=3 and we have classes T1, T2, T3, T4, T5 - first batch will contains {T1,T4}, second - {T2,T5}, third - {T3}.

For example to split Test classes (`LoginUserTest`, `RegisterUserTest`, `UserActivationProcessTest`) into two bathes and execute first batch we should provide `serenity.batch.size = 2`, `serenity.batch.number = 1`. Serenity report will be next:

[[fig-serenity-report-for-equally-batch-strategy-number-1]]
.Serenity report for batch number 1 for equally strategy
image::serenity-report-for-equally-batch-strategy-number-1.png[]

To run same build for second batch, we need provide `serenity.batch.size = 2`, `serenity.batch.number = 2`. In this case Serenity report will be:

[[fig-serenity-report-for-equally-batch-strategy-number-2]]
.Serenity report for batch number 2 for equally strategy
image::serenity-report-for-equally-batch-strategy-number-2.png[]


==== Divide tests to batches using DIVIDE_BY_TEST_COUNT strategy
This strategy will be enabled if during test phase set `serenity.batch.strategy = DIVIDE_BY_TEST_COUNT`.It allows split all test classes among `serenity.batch.size` batches. Value `serenity.batch.number` will refer to some batch and only tests from Test classes from this batch will be executed.
When test phase will be started Serenity will check if `serenity.batch.size > 0` and `serenity.batch.number > 0`, and if so it will split tests classes to `serenity.batch.size` batches and run batch with number equal to `serenity.batch.number`.
All classes will be included to bathes according to numbers of testCases in this classes. This strategy allows split tests between batches optimally. In our case `LoginUserTest` contains 4 tests, `RegisterUserTest` contains 2 tests, `UserActivationProcessTest` contains 2 tests, if we try to split this tests to 2  bathes using this strategy - both batch will contain 4 tests, first one from `LoginUserTest`, second one from `UserActivationProcessTest` and `RegisterUserTest`. It will look like:

[[fig-serenity-report-for-divide-by-test-count-batch-strategy-number-1]]
.Serenity report for batch number 1 for DIVIDE_BY_TEST_COUNT strategy
image::serenity-report-for-divide-by-test-count-batch-strategy-number-1.png[]

[[fig-serenity-report-for-divide-by-test-count-batch-strategy-number-2]]
.Serenity report for batch number 2 for DIVIDE_BY_TEST_COUNT strategy
image::serenity-report-for-divide-by-test-count-batch-strategy-number-2.png[]


=== Configuration parallel executing with Jenkins
This approach is easy to set up on Jenkins using a multi-configuration build. In the following screenshot, we are running a multi-configuration build to run web tests across three batches. We use a single user-defined parameter (BATCH_NUMBER) to define the batch being run, passing this parameter into the Maven build job properties we discussed above.

[[fig-multi-configuration-build]]
.Multi-configuration build to run web tests across three batches
image::parallel-webtests-matrix-build.png[]

The most robust way to aggregate the build results from the different batches is to set up a second build job that runs after the test executions, and retrieves the build results from the batch jobs. You can use the Jenkins Copy Artifacts plugin to do this. First, ensure that the multi-configuration build archives the Serenity reports, as shown here:

[[fig-achieving-serenity-reports]]
.Configuration archiving the Serenity reports
image::parallel-webtests-post-build.png[]

This build will then trigger another, freestyle build job. This job needs to copy the Serenity report artifacts from the matrix build jobs into the current workspace, and then run the mvn serenity:aggregate command to generate the Serenity aggregate reports. The matrix build job reports need to be copied one-by-one for each batch, as the current version of the Copy Artifacts plugin does not support copying from multiple projects in the same action.

[[fig-copying-the-serenity-report-artifacts]]
.Configuration copying the Serenity report artifacts and aggregating reports
image::parallel-webtests-aggregate.png[]

Then make sure you publish the generated HTML reports (which will be in the target/site/serenity directory) for easy access to the test results.

This simple example shows a parallel test running 3 batches – this brought the test execution time from 9 minutes to slightly over 1 minute. Results will vary, of course, but a typical real-world set of web tests would have a larger number of batches