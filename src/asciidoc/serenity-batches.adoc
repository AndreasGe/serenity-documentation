Sometimes projects have a lot of tests, and executing of them takes a lot of time. Testing can be sped up significantly by running different tests in parallel. However, this is often harder to implement than it sounds.

Some build automation tools have builtin parallel test execution, but this not so good for huge amount of tests and heavy tests. For example web tests are as a rule much slower than other types of tests, it make them good candidates for concurrent testing, in theory at least, but the implementation can be tricky. For example, although it is easy enough to configure running tests in parallel, on the other hand running several webdriver instances of Firefox/Chrome in parallel on the same display, tends to become unreliable.

The natural solution in this case is to split the web tests into smaller batches, and to run each batch on a different machine and/or on a different virtual display. When each batch has finished, the results can be retrieved and aggregated into the final test reports.

However splitting tests into batches by hand tends to be tedious and unreliable – it is easy to forget to add a new test to a batch, for example, or have unevenly-distributed batches.

Serenity lets you do this automatically, by splitting your test cases evenly into batches of a given size. In practice, you run a build job for each batch - you take same sources with all tests and configure serenity to run from current copy some amount of test by providing several parameters. After that you retrieve all tests results generated by each batch to aggregate into the final serenity test report.

=== Splitting serenity tests to batches
To split tests to batches you need configure serenity run some tests and skip others. For different batches it will be different tests, below you can find short example of such configuration.

For configuration batches three parameters are used:

*serenity.batch.strategy*:: Optional parameter for choosing batch creating strategy. Possible values are `DIVIDE_EQUALLY` and 'DIVIDE_BY_TEST_COUNT'. Default value is `DIVIDE_EQUALLY`. Instead of it can be used redundant `thucydides.batch.strategy`, but it strongly not recommended

*serenity.batch.size*:: This parameter should be the same for each batch, and should more than 0. This is amount of all bathes for current sources, and synonym of 'serenity.batch.count'. Instead of it can be used redundant `thucydides.batch.size`, but it strongly not recommended

*serenity.batch.count*:: This parameter should be the same for each batch, and should more than 0. This is amount of all bathes for current sources, and synonym of 'serenity.batch.size'. Instead of it can be used redundant `thucydides.batch.count`, but it strongly not recommended

*serenity.batch.number*:: This parameter should be different for each batch, and should be less or equal `serenity.batch.size` and more than 0. This is number of bath for execution in current build. Instead of it can be used redundant `thucydides.batch.number`, but it strongly not recommended

idea of spliting tests to batches. Exiting different strategies

==== Divide equally batch strategy
description and example of using divide tests to batches with DIVIDE_EQUALLY strategy

==== Divide by test count strategy
description and example of using divide tests to batches with DIVIDE_BY_TEST_COUNT strategy

=== Configuration parallel executing with Jenkins
This approach is easy to set up on Jenkins using a multi-configuration build. In the following screenshot, we are running a multi-configuration build to run web tests across three batches. We use a single user-defined parameter (BATCH_NUMBER) to define the batch being run, passing this parameter into the Maven build job properties we discussed above.

[[fig-multi-configuration-build]]
.Multi-configuration build to run web tests across three batches
image::parallel-webtests-matrix-build.png[]

The most robust way to aggregate the build results from the different batches is to set up a second build job that runs after the test executions, and retrieves the build results from the batch jobs. You can use the Jenkins Copy Artifacts plugin to do this. First, ensure that the multi-configuration build archives the Serenity reports, as shown here:

[[fig-achieving-serenity-reports]]
.Configuration archiving the Serenity reports
image::parallel-webtests-post-build.png[]

This build will then trigger another, freestyle build job. This job needs to copy the Serenity report artifacts from the matrix build jobs into the current workspace, and then run the mvn serenity:aggregate command to generate the Serenity aggregate reports. The matrix build job reports need to be copied one-by-one for each batch, as the current version of the Copy Artifacts plugin does not support copying from multiple projects in the same action.

[[fig-copying-the-serenity-report-artifacts]]
.Configuration copying the Serenity report artifacts and aggregating reports
image::parallel-webtests-aggregate.png[]

Then make sure you publish the generated HTML reports (which will be in the target/site/serenity directory) for easy access to the test results.

This simple example shows a parallel test running 3 batches – this brought the test execution time from 9 minutes to slightly over 1 minute. Results will vary, of course, but a typical real-world set of web tests would have a larger number of batches